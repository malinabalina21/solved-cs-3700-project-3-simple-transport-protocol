Download Link: https://assignmentchef.com/product/solved-cs-3700-project-3-simple-transport-protocol
<br>
You will design a simple transport protocol that provides reliable datagram service. Your protocol will be responsible for ensuring data is delivered in order, without duplicates, missing data, or errors. Since the local area networks at Northeastern are far too reliable to be interesting, we will provide you with scripts to set up a vagrant image to emulate an unreliable network.

For the assignment, you will write code that will transfer a file reliably between two nodes (a sender and a receiver). You do <strong>NOT</strong> have to implement connection open/close etc. You may assume that the receiver is run first and will wait indefinitely, and the sender can just send the data to the receiver.

<h3>Requirements</h3>

You have to design your own packet format and use UDP as a carrier to transmit packets. Your packet might include fields for packet type, acknowledgment number, advertised window, data, etc. This part of the assignment is entirely up to you. Your code <em>must</em> meet the following specifications:

<ul>

 <li>Your sending program must be named 3700send and your receiving program must be named 3700recv</li>

 <li>The 3700send accepts data from STDIN, sending data until EOF is reached</li>

 <li>The 3700recv must print out the received data to STDOUT in order and without errors</li>

 <li>Your sender and receiver must gracefully exit</li>

 <li>The sender and receiver must work together to transmit the data reliably</li>

 <li>The sender and receiver must print out specified debugging messages to STDERR</li>

 <li>Your code must be able to transfer a file with any number of packets dropped, damaged, duplicated, and delayed, and under a variety of different available bandwidths and link latencies</li>

 <li>Datagrams generated by your programs must each contain less than or equal to 1472 bytes of data per datagram (i.e. the 1500 byte Ethernet MTU – the 20 byte IP header – the 8 byte UDP header)</li>

</ul>

You may implement any reliability algorithm(s) you choose. However, your implementation must meet certain minimums of performance. Desirable properties in any reliability algorithm include (but are not limited to):

<ul>

 <li>Fast: Require little time to transfer a file.</li>

 <li>Low overhead: Require low data volume to be exchanged over the network, including data bytes, headers, retransmissions, acknowledgments, etc.</li>

</ul>

Being said, correctness matters most: your receiver must output exactly the input to your sender. We will test your code and measure these two performance metrics; better performance will result in higher credit. Remember that network-facing code should be written defensively. Your code should check the integrity of every packet received. We will test your code by reordering packets, delaying packets, and dropping packets. You should handle these errors gracefully, recover, and not crash.

<h3>Your Programs</h3>

For this project, you will submit two programs: a sending program 3700send that accepts data on STDIN and sends it across the network, and a receiving program 3700recv that receives data and prints it to STDOUT in-order. You must use UDP. You may not use any transport protocol libraries in your project (TCP, QUIC, etc).

<h3>Language</h3>

You can write your code in whatever language you choose, as long as your code compiles and runs on <strong>unmodified</strong> Khoury College Linux machines <strong>on the command line</strong>. Do not use libraries that are not installed by default on the Khoury College Linux machines. You may use IDEs (e.g. Eclipse) during development, but do not turn in your IDE project without a Makefile. Make sure you code has <strong>no dependencies</strong> on your IDE.

<h3>Starter Code</h3>

Very basic starter code in C and Python for the assignment is available at <a href="https://course.ccs.neu.edu/cs3700sp20/archive/tcp-starter-c.tgz">tcp-starter-c</a> and <a href="https://course.ccs.neu.edu/cs3700sp20/archive/tcp-starter-py.tgz">tcp-starter-py</a>. You may use this code as a basis for your project, or you may work from scratch. Provided is a simple implementation that sends one packet at a time; it does not handle any packet retransmissions, delayed packets, or duplicated packets. It will only work if the network is perfectly reliable. Moreover, if the latency is significant, the implementation will use very little of the available bandwidth. To get started, you should copy down this directory into your own local directory. You can compile the code by running <em>make</em>. You can also delete any compiled code and object files by running <em>make clean</em>.

<h3>Program Specification</h3>

The command line syntax for your sending is given below. The syntax for launching your sending program must be:

./3700send &lt;recv_host&gt;:&lt;recv_port&gt;

<ul>

 <li>recv_host (Required) The IP address of the remote host in a.b.c.d format.</li>

 <li>recv_port (Required) The UDP port of the remote host.</li>

</ul>

The syntax for launching your receiving program must be:

./3700recv

To aid in grading and debugging, your program must print messages to STDERR.Your sending program must print at least the following:

<ul>

 <li>“&lt;timestamp&gt; [send data] start (length)”When the sender sends a packet (including retransmission). Here, <em>timestamp</em> is a timestamp (down to the microsecond), <em>start</em> is the beginning offset of the data sent in the packet, and <em>length</em> is the amount of the data sent in that packet.</li>

 <li>“&lt;timestamp&gt; [recv ack] end”When 3700send receives an acknowledgment. Here, <em>end</em> is the last offset that was acknowledged.</li>

 <li>“&lt;timestamp&gt; [completed]”Upon completion of file transfer, just before exiting.</li>

</ul>

Your receiving program must print at least the following:

<ul>

 <li>“&lt;timestamp&gt; [bound] port”When the receiving program has started up and bound to a port. Here, <em>port</em> is the bound port held by the receiver.</li>

 <li>“&lt;timestamp&gt; ([recv data] start (length) status | IGNORED)”Upon receiving a valid data packet. Here, <em>start</em> is the beginning offset of the data sent in the packet, <em>length</em> is the amount of the data sent in that packet, and <em>status</em> is one of “ACCEPTED (in-order)” or “ACCEPTED (out-of-order)”</li>

 <li>“&lt;timestamp&gt; [recv corrupt packet]”Upon receiving a corrupt packet.</li>

 <li>“&lt;timestamp&gt; [completed]”Upon completion of file transfer, just before exiting.</li>

</ul>

You may also print concise and readable messages of your own to indicate timeouts, etc. In the C starter code, the function <em>mylog(char *fmt, …)</em> is provided for this purpose.

You should develop your client program on the Khoury College Vagrant image. You are welcome to develop your own Linux/OS X/Windows machines, but you are responsible for getting your code working, and your code will be graded on the Vagrant image.

<h3>Testing Your Code</h3>

In order for you to test your code over an unreliable network, we are providing scripts to setup a Vagrant image that will emulate a network that drops, reorders, duplicates, and delays your packets. These scripts are tested to work on the Vagrant image, and are known <strong>NOT TO WORK</strong> on Khoury machines managed by Systems. You will need to use the loopback interface in order to leverage the emulated network. In other words, you might run something like <em>./3700recv</em> in one terminal, record the port it local binds to (say, 3992), and then run <em>./3700send 127.0.0.1:3992</em> in another terminal.

The scripts mentioned below are available in the archive <a href="https://course.ccs.neu.edu/cs3700sp20/archive/tcp-sim.tgz">tcp-sim</a>. The file should be untar’d in the same directory as your 3700send and 3700recv executables.

You may configure the emulated network conditions by calling the following program:

netsim [–bandwidth &lt;bw-in-mbps&gt;]        [–latency &lt;latency-in-ms&gt;] [–delay &lt;percent&gt;]        [–drop &lt;percent&gt;]        [–reorder &lt;percent&gt;] [–duplicate &lt;percent&gt;]

<ul>

 <li><strong>bandwidth:</strong> This sets the bandwidth of the link in Mbit per second. If not specified, this is 1 Mb/s.</li>

 <li><strong>latency</strong>: This sets the latency of the link in ms. If not specified, this value is 10 ms.</li>

 <li><strong>delay</strong>: This sets the percent of packets the emulator should delay. If not specified, this is 0.</li>

 <li><strong>drop</strong>: This sets the percent of packets the emulator should drop. If not specified, this is 0.</li>

 <li><strong>reorder</strong>: This sets the percent of packets the emulator should reorder. If not specified, this is 0.</li>

 <li><strong>duplicate</strong>: This sets the percent of packets the emulator should duplicate. If not specified, this is 0.</li>

</ul>

Once you call this program, it will configure the emulator to delay/drop/reorder/duplicate all UDP and ICMP packets sent by or to you at the specified rate. For example, if you called

./netsim –bandwidth 0.5 –latency 100 –delay 20 –drop 40

the simulator will configure a network with 500 Kb/s bandwidth and a latency of 100 ms, and will randomly delay 20% of your packets and drop 40%. In order to reset it so that none of your packets are disturbed, you can simply call netsim with no arguments. <strong>Note that the simulator is stateful</strong>, meaning your settings will persist across multiple sessions.

<h3>Helper Script</h3>

In order to make testing your code easier, we have also included a perl script that will launch your receiver, read the port number, launch your sender, feed the sender input, read the output from the receiver, compare the two, and print out statistics about the transfer. This script is included in the simulator code tarball, and you can run it by executing

./run

This script also takes a couple of arguments to determine what it should do:

./run [–size (small|medium|large|huge)] [–printlog] [–timeout &lt;seconds&gt;]

<ul>

 <li><strong>size</strong>: The size of the data to send, including 1 KB (small), 10 KB (medium), 100 KB (large), 1MB (huge). Default is small.</li>

 <li><strong>printlog</strong>: Instructs the script to print a (sorted) log of the debug output of 3700send and 3700recv. This may add significant processing time, depending on the amount of output.</li>

 <li><strong>timeout</strong>: The maximum number of seconds to run the sender and receiver before killing them. Defaults to 30 seconds.</li>

</ul>

The output of this script include some statistics about the transfer:

bash$ ./run –size largeTime elapsed: 1734.921 msPackets sent: 140Bytes sent: 107000Effective goodput: 461.116Kb/s Data match: Yes

where “Data match” indicates whether the data was transferred correctly.

<h3>Testing Script</h3>

Additionally, we have included a testing script that runs your code under a variety of network conditions. The tests provided in the testing scripts are materially the same as the ones your code will be graded against. To run the test script, simply type

bash$ ./test

This will compile your code and then test your programs on a number of inputs. If any errors are detected, the test will print out the expected and actual output.

<strong>Note</strong>: The testing script has the same restrictions as netsim with regards to where it can be run.

<h3>Performance Testing</h3>

20% of your grade on this project will come from performance. To help you know how you’re doing, the testing script will also run a series of performance tests at the end; for each test that you successfully complete, it will report your time elapsed and bytes sent. For example, you might see

Performance tests    Huge 5Mb/s, 10 ms               [DATA OK]    13.889 sec elapsed, 1.1MB sent

This indicates that your code sent the correct data in 13.889 seconds, using a total of 1.1MB of data including retransmissions, overhead, etc. Using the following equations, we can calculate the minimum number of packets and according minimal time it will take a simplified model<sup>[<a href="https://course.ccs.neu.edu/cs3700sp20/projects/project3.html#assumptions">1</a>]</sup> of transmission to take.

P_th = ceil(total_data/packet_size) P_min = 2 * P_th * (1 + drop_rate)T_min = P_th * (1 + drop_rate) * (T_latency + packet_size/line_rate)

Note: delays, reorders, and duplicates do not impact this model. We will add a “fudge-factor” of 5% to drop_rate on tests that involve any of these.

We will use the following breakdown for evaluating performance when grading code. Variables can be calculates as described above, and time and packet count will be weighted equally.

<table>

 <thead>

  <tr>

   <td>Max Transfer Time</td>

   <td>Max Packets (with non-zero errors)</td>

   <td>Value</td>

  </tr>

 </thead>

 <tbody>

  <tr>

   <td>.5T_min</td>

   <td>1.3P_min</td>

   <td>141.7%</td>

  </tr>

  <tr>

   <td>.55T_min</td>

   <td>1.4P_min</td>

   <td>100%</td>

  </tr>

  <tr>

   <td>.7T_min</td>

   <td>1.5P_min</td>

   <td>80%</td>

  </tr>

  <tr>

   <td>.85T_min</td>

   <td>1.65P_min</td>

   <td>60%</td>

  </tr>

  <tr>

   <td>T_min</td>

   <td>1.8P_min</td>

   <td>40%</td>

  </tr>

  <tr>

   <td>2T_min</td>

   <td>2P_min</td>

   <td>20%</td>

  </tr>

  <tr>

   <td>∞</td>

   <td>∞</td>

   <td>0%</td>

  </tr>

 </tbody>

</table>